using System.Collections.Generic;
using System.Linq;
using CAESAR.Chess.Core;
using CAESAR.Chess.Helpers;
using CAESAR.Chess.PlayArea;

namespace CAESAR.Chess.Moves.Generation
{
    /// <summary>
    ///     Generates <seealso cref="IMove" />s for a particular <seealso cref="ISquare" />, based on a particular set of move
    ///     generation rules. Directed moves are those which extend in a particular direction but stop when a piece is met or
    ///     at the end of the board. Examples are queen, bishop, and rook.
    /// </summary>
    public abstract class DirectedMovesGenerator : MovesGenerator
    {
        /// <summary>
        ///     The <seealso cref="Direction" />s in which this <seealso cref="MovesGenerator" /> can generate directed
        ///     <seealso cref="IMove" />s.
        /// </summary>
        protected abstract IEnumerable<Direction> Directions { get; }

        /// <summary>
        ///     The <seealso cref="ISquare" />s to which the <seealso cref="MovesGenerator.Piece" /> can move.
        /// </summary>
        protected override IEnumerable<ISquare> MovementSquares
            => Directions.SelectMany(GetAdjacentSquaresInDirectionTillNonEmptySquare);

        /// <summary>
        ///     The <seealso cref="ISquare" />s which the <seealso cref="MovesGenerator.Piece" /> can capture.
        /// </summary>
        public override IEnumerable<ISquare> CaptureSquares => MovementSquares;

        /// <summary>
        ///     The special moves generated by this <seealso cref="MovesGenerator" />. For a
        ///     <seealso cref="DirectedMovesGenerator" /> there are no special <seealso cref="IMove" />s.
        /// </summary>
        protected override IEnumerable<IMove> SpecialMoves => Enumerable.Empty<IMove>();

        /// <summary>
        ///     Returns the adjacent <seealso cref="ISquare" />s in the specified <seealso cref="Direction" /> until a non-empty
        ///     <seealso cref="ISquare" />.
        /// </summary>
        /// <param name="direction">The <seealso cref="Direction" /> in which to look for adjacent <seealso cref="ISquare" />s.</param>
        /// <returns>
        ///     The adjacent <seealso cref="ISquare" />s in the specified <seealso cref="Direction" /> until a non-empty
        ///     <seealso cref="ISquare" /> if available.
        /// </returns>
        private IEnumerable<ISquare> GetAdjacentSquaresInDirectionTillNonEmptySquare(Direction direction)
        {
            return Square.GetAdjacentSquaresInDirection(direction)
                .TakeWhileUntil(x => x != null && x.Piece == null, x => x.Piece != null);
        }
    }
}