using System.Collections.Generic;
using System.Linq;
using CAESAR.Chess.Core;
using CAESAR.Chess.Helpers;
using CAESAR.Chess.Pieces;
using CAESAR.Chess.PlayArea;
using CAESAR.Chess.Positions;

namespace CAESAR.Chess.Moves.Generation
{
    /// <summary>
    ///     Generates <seealso cref="IMove" />s for a particular <seealso cref="ISquare" />, based on the move
    ///     generation rules of the <seealso cref="King" />.
    /// </summary>
    public class KingMovesGenerator : MovesGenerator
    {
        /// <summary>
        ///     The <seealso cref="Direction" />s that the <seealso cref="King" /> is allowed to move in.
        /// </summary>
        private static readonly IEnumerable<Direction> Directions = new[]
        {
            Direction.Up,
            Direction.UpRight,
            Direction.Right,
            Direction.DownRight,
            Direction.Down,
            Direction.DownLeft,
            Direction.Left,
            Direction.UpLeft
        };

        /// <summary>
        ///     The special moves generated by this <seealso cref="MovesGenerator" />. For the
        ///     <seealso cref="KingMovesGenerator" /> this includes one of the two <seealso cref="CastlingMove" />s which may be
        ///     available based on the position.
        /// </summary>
        protected override IEnumerable<IMove> SpecialMoves => GetCastlingMoves();

        /// <summary>
        ///     The <seealso cref="ISquare" />s to which the <seealso cref="MovesGenerator.Piece" /> can move.
        /// </summary>
        protected override IEnumerable<ISquare> MovementSquares
            => Directions.Select(Square.GetAdjacentSquareInDirection);

        /// <summary>
        ///     The <seealso cref="ISquare" />s which the <seealso cref="MovesGenerator.Piece" /> can capture.
        /// </summary>
        protected override IEnumerable<ISquare> CaptureSquares
            => Directions.Select(Square.GetAdjacentSquareInDirection);

        /// <summary>
        ///     Gets the <seealso cref="CastlingMove" />s available for this <seealso cref="King" />.
        /// </summary>
        /// <returns>The <seealso cref="CastlingMove" />s available for this <seealso cref="King" />.</returns>
        private IEnumerable<CastlingMove> GetCastlingMoves()
        {
            var board = Square.Board;
            var position = board.Position;
            var availability = position.CastlingRights;
            if (availability == CastlingRights.None)
                yield break;
            if (position.IsInCheck(Side))
                yield break;
            if (Side == Side.White)
            {
                if (availability.HasFlag(CastlingRights.WhiteShort) && board.GetSquare("f1").IsEmpty &&
                    board.GetSquare("g1").IsEmpty)
                    yield return new CastlingMove(Square, CastlingType.Kingside);
                if (availability.HasFlag(CastlingRights.WhiteLong) && board.GetSquare("b1").IsEmpty &&
                    board.GetSquare("c1").IsEmpty && board.GetSquare("d1").IsEmpty)
                    yield return new CastlingMove(Square, CastlingType.Queenside);
                yield break;
            }
            if (Side == Side.Black)
            {
                if (availability.HasFlag(CastlingRights.BlackShort) && board.GetSquare("f8").IsEmpty &&
                    board.GetSquare("g8").IsEmpty)
                    yield return new CastlingMove(Square, CastlingType.Kingside);
                if (availability.HasFlag(CastlingRights.BlackLong) && board.GetSquare("b8").IsEmpty &&
                    board.GetSquare("c8").IsEmpty && board.GetSquare("d8").IsEmpty)
                    yield return new CastlingMove(Square, CastlingType.Queenside);
            }
        }
    }
}