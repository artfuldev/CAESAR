using System;
using System.Collections.Generic;
using System.Linq;
using CAESAR.Chess.Core;
using CAESAR.Chess.Helpers;
using CAESAR.Chess.Pieces;
using CAESAR.Chess.PlayArea;

namespace CAESAR.Chess.Moves.Generation
{
    /// <summary>
    ///     Generates <seealso cref="IMove" />s for a particular <seealso cref="ISquare" />, based on the move
    ///     generation rules of the <seealso cref="Pawn" />.
    /// </summary>
    public class PawnMovesGenerator : MovesGenerator
    {
        /// <summary>
        ///     The <seealso cref="Direction" />s in which a <seealso cref="Side.White" /> <seealso cref="Pawn" /> can capture.
        /// </summary>
        private static readonly IEnumerable<Direction> WhitePawnCaptureDirections = new[]
        {Direction.UpRight, Direction.UpLeft};

        /// <summary>
        ///     The <seealso cref="Direction" />s in which a <seealso cref="Side.Black" /> <seealso cref="Pawn" /> can capture.
        /// </summary>
        private static readonly IEnumerable<Direction> BlackPawnCaptureDirections = new[]
        {Direction.DownRight, Direction.DownLeft};

        /// <summary>
        ///     The <seealso cref="PieceType" />s to which a <seealso cref="Pawn" /> can be promoted.
        /// </summary>
        private static readonly PieceType[] PromotionPieceTypes =
        {
            PieceType.Queen, PieceType.Rook, PieceType.Bishop,
            PieceType.Knight
        };

        /// <summary>
        ///     The special moves generated by this <seealso cref="MovesGenerator" />. For the
        ///     <seealso cref="PawnMovesGenerator" />, this includes <seealso cref="PromotionMove" />s and an
        ///     <seealso cref="EnPassantMove" /> for the <seealso cref="Pawn" /> at the <seealso cref="IMovesGenerator.Square" />.
        /// </summary>
        protected override IEnumerable<IMove> SpecialMoves
        {
            get
            {
                var enPassantMove = GetEnPassantMove();
                return PromotionMoves()
                    .Cast<IMove>()
                    .Concat(enPassantMove == null ? Enumerable.Empty<EnPassantMove>() : new[] {enPassantMove});
            }
        }

        /// <summary>
        ///     The <seealso cref="ISquare" />s to which the <seealso cref="Pawn" /> can move, from
        ///     <seealso cref="IMovesGenerator.Square" />.
        /// </summary>
        protected override IEnumerable<ISquare> MovementSquares => PawnMovementSquares();

        /// <summary>
        ///     The <seealso cref="ISquare" />s which the <seealso cref="Pawn" /> can capture, from
        ///     <seealso cref="IMovesGenerator.Square" />.
        /// </summary>
        protected override IEnumerable<ISquare> CaptureSquares => Square.Rank.Number == PromotionRankNumber
            ? Enumerable.Empty<ISquare>()
            : PawnCaptureDirections.Select(Square.GetAdjacentSquareInDirection);

        /// <summary>
        ///     The <seealso cref="Direction" /> in which a <seealso cref="Pawn" /> is allowed to move.
        /// </summary>
        private Direction PawnMovementDirection
            => Side == Side.White ? Direction.Up : Side == Side.Black ? Direction.Down : Direction.None;

        /// <summary>
        ///     Denotes if a <seealso cref="Pawn" /> is in its starting rank, according to the rules of chess. For a
        ///     <seealso cref="Side.White" /> <seealso cref="Pawn" /> the starting rank is 2 while for a
        ///     <seealso cref="Side.Black" /> one, it is 7.
        /// </summary>
        private bool IsStartingRank
            => Side == Side.White ? Square.Rank.Number == 2 : Side == Side.Black && Square.Rank.Number == 7;

        /// <summary>
        ///     The <seealso cref="Direction" />s in which a <seealso cref="Pawn" /> can capture.
        /// </summary>
        private IEnumerable<Direction> PawnCaptureDirections
            =>
                Side == Side.White
                    ? WhitePawnCaptureDirections
                    : Side == Side.Black ? BlackPawnCaptureDirections : Enumerable.Empty<Direction>();

        /// <summary>
        ///     The rank number for the <seealso cref="Pawn" />, based on its <seealso cref="IPiece.Side" />, at which it can be
        ///     promoted.
        /// </summary>
        private int PromotionRankNumber => Side == Side.White ? 7 : Side == Side.Black ? 2 : 0;

        /// <summary>
        ///     The rank number for the <seealso cref="Pawn" />, based on its <seealso cref="IPiece.Side" />, at which it can
        ///     perform an <seealso cref="EnPassantMove" />.
        /// </summary>
        private int EnPassantRankNumber => Side == Side.White ? 5 : Side == Side.Black ? 4 : 0;

        /// <summary>
        ///     The <seealso cref="ISquare" />s to which a <seealso cref="Pawn" /> can move, from
        ///     <seealso cref="IMovesGenerator.Square" />.
        /// </summary>
        /// <returns>
        ///     The <seealso cref="ISquare" />s to which a <seealso cref="Pawn" /> can move, from
        ///     <seealso cref="IMovesGenerator.Square" />.
        /// </returns>
        private IEnumerable<ISquare> PawnMovementSquares()
        {
            var promotionRankNumber = PromotionRankNumber;
            if (Square.Rank.Number == promotionRankNumber)
                yield break;
            var direction = PawnMovementDirection;
            var movementSquare = Square.GetAdjacentSquareInDirection(direction);
            yield return movementSquare;
            if (IsStartingRank && movementSquare.Piece == null)
                yield return movementSquare.GetAdjacentSquareInDirection(direction);
        }

        /// <summary>
        ///     The <seealso cref="PromotionMove" />s which the <seealso cref="Pawn" /> in
        ///     <seealso cref="IMovesGenerator.Square" /> can make.
        /// </summary>
        /// <returns>
        ///     The <seealso cref="PromotionMove" />s which the <seealso cref="Pawn" /> in
        ///     <seealso cref="IMovesGenerator.Square" /> can make.
        /// </returns>
        private IEnumerable<PromotionMove> PromotionMoves()
        {
            var promotionRankNumber = PromotionRankNumber;
            if (Square.Rank.Number != promotionRankNumber)
                return Enumerable.Empty<PromotionMove>();
            var eligibleSquares =
                // Capture Promotion
                PawnCaptureDirections
                    .Select(Square.GetAdjacentSquareInDirection)
                    .Where(x => x.HasPiece && x.Piece.Side != Side).ToList();
            // Movement Promotion
            var movementSquare = Square.GetAdjacentSquareInDirection(PawnMovementDirection);
            if (!movementSquare.HasPiece)
                eligibleSquares.Add(movementSquare);
            return eligibleSquares.SelectMany(GetPromotionMoves);
        }

        /// <summary>
        ///     Gets the <seealso cref="PromotionMove" />s for a particular destination <seealso cref="ISquare" />, for a
        ///     <seealso cref="Pawn" /> in <seealso cref="IMovesGenerator.Square" />. One <seealso cref="PromotionMove" /> for each
        ///     <seealso cref="PieceType" /> available in <seealso cref="PromotionPieceTypes" />.
        /// </summary>
        /// <param name="destination">The <seealso cref="ISquare" /> to which the pawn is promoting.</param>
        /// <returns>
        ///     The <seealso cref="PromotionMove" />s for a particular destination <seealso cref="ISquare" />, for a
        ///     <seealso cref="Pawn" /> in <seealso cref="IMovesGenerator.Square" />. One <seealso cref="PromotionMove" /> for each
        ///     <seealso cref="PieceType" /> available in <seealso cref="PromotionPieceTypes" />.
        /// </returns>
        private IEnumerable<PromotionMove> GetPromotionMoves(ISquare destination)
        {
            return
                PromotionPieceTypes.Select(
                    pieceType =>
                        destination.HasPiece
                            ? new CapturingPromotionMove(Square, destination.Name, pieceType)
                            : new PromotionMove(Square, destination.Name, pieceType));
        }

        /// <summary>
        ///     Gets the <seealso cref="EnPassantMove" /> for the <seealso cref="Pawn" /> in
        ///     <seealso cref="IMovesGenerator.Square" /> at this position, if available.
        /// </summary>
        /// <returns>
        ///     The <seealso cref="EnPassantMove" /> for the <seealso cref="Pawn" /> in
        ///     <seealso cref="IMovesGenerator.Square" /> at this position, if available. Otherwise returns null.
        /// </returns>
        private EnPassantMove GetEnPassantMove()
        {
            var enPassantSquare = Square.Board.Position.EnPassantSquare;
            if (enPassantSquare == null ||
                Square.Rank.Number != EnPassantRankNumber ||
                Math.Abs(Square.File.Name - enPassantSquare.File.Name) != 1 ||
                Math.Abs(Square.Rank.Number - enPassantSquare.Rank.Number) != 1)
                return null;
            return new EnPassantMove(Square, enPassantSquare.Name);
        }
    }
}